---
output:
  pdf_document:
    includes:
      in_header: tex/preamble.tex
    fig_caption: false
    keep_tex: true
documentclass: article
---

```{r setup, include=FALSE, message=FALSE}
knitr::opts_chunk$set(echo = TRUE, message=FALSE, warning=FALSE)
knitr::knit_hooks$set(hook_convert_odg = rmdhelp::hook_convert_odg)
library(dplyr)
# decide from where data is read
b_online <- TRUE
if (b_online){
  s_data_root <- "https://charlotte-ngs.github.io/lbgfs2022/data"
} else {
  s_data_root <- file.path(here::here(), "docs", "data")
}

```

```{r TaskCounts, echo=FALSE}
cnt <- rmdhelp::R6ClassCount$new()
cnt$set_prefix(ps_prefix = "## Problem")
```

```{r PointAssignment, echo=FALSE}
# Assign Points for Q1
lPointsQ1 <- list(TaskA = 6,
                  TaskB = 15,
                  TaskC = 6,
                  TaskD = 0)
nPointQ1Total <- sum(unlist(lPointsQ1))
# Assign Points for Q2
lPointsQ2 <- list(TaskA = 6,
                  TaskB = 16,
                  TaskC = 3)
nPointQ2Total <- sum(unlist(lPointsQ2))
# Assign Points for Q3
lPointsQ3 <- list(TaskA = 20,
                  TaskB = 25,
                  TaskC = 2)
nPointQ3Total <- sum(unlist(lPointsQ3))
# Assign Points for Q4
lPointsQ4 <- list(TaskA = 22,
                  TaskB = 6,
                  TaskC = 0)
nPointQ4Total <- sum(unlist(lPointsQ4))
# Assign Points for Q5
lPointsQ5 <- list(TaskA = 4,
                  TaskB = 2,
                  TaskC = 6,
                  TaskD = 10)
nPointQ5Total <- sum(unlist(lPointsQ5))
# compute overal sum of points
nPointOverallTotal <- nPointQ1Total + nPointQ2Total + nPointQ3Total + nPointQ4Total + nPointQ5Total
```

\thispagestyle{empty}

```{=tex}
\begin{tabular}{l}
ETH Zurich \\
D-USYS\\
Institute of Agricultural Sciences\\
\end{tabular}
```
```{=tex}
\vspace{15ex}
\begin{center}
\huge
Solutions To Exam\\ \vspace{1ex}
Livestock Breeding and Genomics \\  \vspace{1ex}
FS 2022 \\

\normalsize
\vspace{7ex}
Peter von Rohr 
\end{center}
```
```{=tex}
\vspace{7ex}
\begin{tabular}{p{5cm}lr}
  & \textsc{Date}  & \textsc{\emph{23. December 2022}} \\
  & \textsc{Begin} & \textsc{\emph{09:15 }}\\
  & \textsc{End}   & \textsc{\emph{11:15 }}\\ 
\end{tabular}
```
\vspace{5ex}

<!-- Table with Name -->

```{=tex}
\large
\begin{tabular}{p{2.5cm}p{3cm}p{6cm}}
  &  Name:     &  \\
  &            &  \\
  &  Legi-Nr:  & \\
\end{tabular}
\normalsize
```
<!-- Table with Points -->

```{=tex}
\vspace{9ex}
\begin{center}
\begin{tabular}{|p{3cm}|c|c|}
\hline
Problem  &  Maximum Number of Points  &  Number of Points Reached \\
\hline
1        &  `r nPointQ1Total`         & \\
\hline
2        &  `r nPointQ2Total`         & \\
\hline
3        &  `r nPointQ3Total`         & \\
\hline
4        &  `r nPointQ4Total`          & \\
\hline
5        &  `r nPointQ5Total`          & \\
\hline
Total    &  `r nPointOverallTotal`    & \\
\hline
\end{tabular}
\end{center}
```
```{=tex}
\clearpage
\pagebreak
```
```{r, echo=FALSE, results='asis'}
cat(cnt$out(ps_suffix = "Quantitative Genetics"), "\n")
```

```{r, echo=FALSE}
# read the data
s_data_p1_path <- file.path(s_data_root, "lbgfs2022_exam_problem1.csv")
tbl_data_p01 <- readr::read_delim(s_data_p1_path, 
                                  delim = ",",
                                  col_types = readr::cols(
                                    Animal = readr::col_integer(),
                                    SNP_1 = readr::col_integer(),
                                    SNP_2 = readr::col_integer(),
                                    Observation = readr::col_double()
                                  ))
#head(tbl_data_p01)
```


The following dataset contains observations of a phenotypic trait and genotypes for two loci. The numbers in the columns `SNP_1` and `SNP_2` count the number of alleles with a positive effect on the observation. Genotypic values of heterozygous animals are assumed to be right between the genotypic values of homozygous animals ($d=0$). 

\textit{Der folgende Datensatz enthält Beobachtungen für ein phänotypisches Merkmal und Genotypen von zwei Loci. Die Zahlen in den Kolonnen } \verb+SNP_1+ \textit{ und } \verb+SNP_2+ \textit{ zählen die Anzahl Allele mit einem positiven Effekt auf den Merkmalswert. Genotypische Werte der heterozygoten Tiere sind genau in der Mitte zwischen den genotypischen Werten der homozygoten Tiere} ($d=0$).

```{r, echo=FALSE}
knitr::kable(tbl_data_p01, booktabs = TRUE, longtable = TRUE)
```


```{=tex}
\clearpage
\pagebreak
```

The dataset as shown in the table above is available under: 

\textit{Der oben gezeigte Datensatz ist verfügbar unter:}

```{r, echo=FALSE, results='asis'}
cat(s_data_p1_path, "\n")
```

\vspace{3ex}
```{=tex}
\begin{enumerate}
\item[a)] Compute the genotypic values for all genotypes of the two loci  \verb+SNP_1+ and \verb+SNP_2+ using the above dataset.

\textit{Berechnen Sie die genotypischen Werte aller Genotypen für die zwei Loci } \verb+SNP_1+ \textit{ und } \verb+SNP_2+ basierend auf dem oben gezeigtem Datensatz.  
\points{`r lPointsQ1$TaskA`}
\end{enumerate}
```


\solstart
First, the data is read

```{r}
s_data_p1_path <- file.path(s_data_root, "lbgfs2022_exam_problem1.csv")
tbl_data_p01 <- readr::read_delim(s_data_p1_path, 
                                  delim = ",",
                                  col_types = readr::cols(
                                    Animal = readr::col_integer(),
                                    SNP_1 = readr::col_integer(),
                                    SNP_2 = readr::col_integer(),
                                    Observation = readr::col_double()
                                  ))
```

The genotypic values of the homozygous genotypes can be computed based on a linear regression. This regression model can be formulated as follows.

```{r}
lm_joint <- lm(Observation ~ SNP_1 + SNP_2, data = tbl_data_p01)
(smry_joint <- summary(lm_joint))
```

The genotypic values can then be summarized in the following table

```{r, echo=FALSE}
tbl_genotypic_values <- tibble::tibble(Genotype = c(0:2),
                                       SNP_1 = c(-smry_joint$coefficients["SNP_1", "Estimate"],
                                                 0,
                                                 smry_joint$coefficients["SNP_1", "Estimate"]),
                                       SNP_2 = c(-smry_joint$coefficients["SNP_2", "Estimate"],
                                                 0,
                                                 smry_joint$coefficients["SNP_2", "Estimate"]))
knitr::kable(tbl_genotypic_values, booktabs = TRUE, longtable = TRUE)
```


\solend

```{=tex}
\clearpage
\pagebreak
```
```{=tex}
\begin{enumerate}
\item[b)] Compute the breeding values and the dominance deviations for all animals in the above dataset. Allele frequencies can be determined based on the given dataset.

\textit{Berechnen Sie die Zuchtwerte und die Dominanzabweichungen aller Tiere im oben gegebenen Datensatz. Die Allelefrequenzen sollen aufgrund des gegebenen Datensatzes bestimmt werden.}
\points{`r lPointsQ1$TaskB`}
\end{enumerate}
```

\solstart
The breeding values are computed as 

```{r, echo=FALSE}
tbl_breeding_values <- tibble::tibble(Genotype = c(0:2),
                                      General  = c("$2q \\alpha$",
                                                   "$(q-p) \\alpha$",
                                                   "$-2p \\alpha$"))
knitr::kable(tbl_breeding_values, booktabs = TRUE, longtable = TRUE, escape = FALSE)
```

where $\alpha = a + (q-p)d$ with $d=0$, we get $\alpha = a$. The value for $a$ corresponds to the absolute value of the genotypic values of the homozygous genotypes. The genotypic values are computed as shown in Problem 1a)

```{r}
lm_joint <- lm(Observation ~ SNP_1 + SNP_2, data = tbl_data_p01)
smry_joint <- summary(lm_joint)
vec_genotypic_value <- c(smry_joint$coefficients["SNP_1", "Estimate"], 
                         smry_joint$coefficients["SNP_2", "Estimate"])
```


The variables $p$ and $q$ represent the allele frequencies. The allele frequencies are determined using the following chunk

```{r}
library(dplyr)
tbl_freq_allele <- tbl_data_p01 %>% 
  summarise(freq_pos_allele_SNP1 = sum(SNP_1) / (2*nrow(tbl_data_p01)))
tbl_freq_allele <- dplyr::bind_cols(tbl_freq_allele,
                                    tbl_data_p01 %>% 
  summarise(freq_pos_allele_SNP2 = sum(SNP_2) / (2*nrow(tbl_data_p01))))
tbl_freq_allele
vec_allele_freq <- c(tbl_freq_allele$freq_pos_allele_SNP1, 
                     tbl_freq_allele$freq_pos_allele_SNP2)
```

The the following table gives an overview over the breeding values for every single-locus genotype.

```{r, echo=FALSE}
tbl_breeding_value_results <- tibble::tibble(Genotype = c(0:2),
                  BVSNP1    = c(-2*vec_allele_freq[1] * vec_genotypic_value[1],
                             (1-2*vec_allele_freq[1]) * vec_genotypic_value[1],
                             2*(1-vec_allele_freq[1]) * vec_genotypic_value[1]),
                  BVSNP2    = c(-2*vec_allele_freq[2] * vec_genotypic_value[2],
                             (1-2*vec_allele_freq[2]) * vec_genotypic_value[2],
                             2*(1-vec_allele_freq[2]) * vec_genotypic_value[2]))
knitr::kable(tbl_breeding_value_results, booktabs = TRUE, longtable = TRUE, escape = FALSE)
```

The breeding values of all animals are


```{r}
# snp1
tbl_breeding_value_bv1 <- tbl_breeding_value_results %>% select(Genotype, BVSNP1)
tbl_bv_snp1 <- tbl_data_p01 %>% 
  inner_join(tbl_breeding_value_bv1, by = c("SNP_1" = "Genotype")) %>%
  select(Animal, BVSNP1)
# snp2
tbl_breeding_value_bv2 <- tbl_breeding_value_results %>% select(Genotype, BVSNP2)
tbl_bv_snp2 <- tbl_data_p01 %>% 
  inner_join(tbl_breeding_value_bv2, by = c("SNP_2" = "Genotype")) %>%
  select(Animal, BVSNP2)
# total
tbl_bv_total <- bind_cols(tbl_bv_snp1, tbl_bv_snp2 %>% select(BVSNP2))
tbl_bv_total <- tbl_bv_total %>%
  mutate(BVTotal = BVSNP1 + BVSNP2)

# show the table
knitr::kable(tbl_bv_total, booktabs = TRUE, longtable = TRUE)
```



Dominance deviations are all $0$, because $d=0$ for both loci.

\solend

```{=tex}
\clearpage
\pagebreak
```
```{=tex}
\begin{enumerate}
\item[c)]  Compute the genetic additive variance $\sigma_A^2$ and the dominance variance $\sigma_D^2$ for the trait in the given dataset over both loci.

\textit{Berechnen Sie die genetisch-additive Varianz } $\sigma_A^2$ \textit{ und die Dominanzvarianz } $\sigma_D^2$ für das Merkmal im Datensatz über beide Loci. 
\points{`r lPointsQ1$TaskC`}
\end{enumerate}
```

\solstart
The genetic additive variance $\sigma_A^2$ for a single locus is computed as 

$$\sigma_A^2 = 2pq\alpha^2$$

with $d=0$, we get $\alpha = a$ and $\sigma_A^2 = 2pqa^2$. This is computed for both loci and then added together.

Based on the results, we got so far, we get

```{r}
n_sigma_a2_snp1 <- 2 * vec_allele_freq[1] * (1-vec_allele_freq[1]) * 
  vec_genotypic_value[1]^2
n_sigma_a2_snp2 <- 2 * (vec_allele_freq[2]) * (1-vec_allele_freq[2]) * 
  vec_genotypic_value[2]^2
n_sigma_a2_tot <- n_sigma_a2_snp1 + n_sigma_a2_snp2
```

$$\sigma_{A,SNP1}^2 = 2 * `r vec_allele_freq[1]` * (1 - `r vec_allele_freq[1]`) * `r vec_genotypic_value[1]`^2 = `r n_sigma_a2_snp1`$$
$$\sigma_{A,SNP2}^2 = 2 * `r vec_allele_freq[2]` * (1 - `r vec_allele_freq[2]`) * `r vec_genotypic_value[2]`^2 = `r n_sigma_a2_snp2`$$
$$\sigma_A^2 = \sigma_{A,SNP1}^2 + \sigma_{A,SNP2}^2 = `r n_sigma_a2_snp1` + `r n_sigma_a2_snp2` = `r n_sigma_a2_tot`$$

The dominance variance $\sigma_D^2$ is $0$ for both loci, because $d=0$. 

\solend

```{=tex}
\clearpage
\pagebreak
```
```{r, echo=FALSE, results='asis'}
cat(cnt$out(ps_suffix = "Relationship and Inbreeding"), "\n")
```

Starting on 01.01.2023, the Swiss Federal Office of Agriculture will start to pay subsidies to owners of livestock animals of endangered breeds. The amount of subsidies will be based on an index which among other components is based on the average inbreeding coefficient of animals and on the average age of the owners of the animals. Below we are given two example pedigrees of two different breeds. 

\textit{Ab 01.01.2023 wird das Bundesamt für Landwirtschaft Subventionen an Halter von Nutztieren seltener Rassen auszahlen. Die Höhe der Subventionen wird auf einem Index basieren. Dieser Index wird neben anderen Komponenten auch den durchschnittlichen Inzuchtkoeffizient der Tiere und das mittlere Alter der Halter beinhalten. Unten sind zwei Beispielpedigrees von zwei verschiedenen Rassen gegeben.}

```{r, echo=FALSE}
s_ped1_path <- file.path(s_data_root, "lbgfs2022_exam_problem2_pedigree1.csv")
tbl_ped1_p02 <- readr::read_delim(s_ped1_path, 
                                  delim = ",",
                                  col_types = readr::cols(
                                    id = readr::col_character(),
                                    sire = readr::col_character(),
                                    dam = readr::col_character(),
                                    AgeOwner = readr::col_double()
                                  ))
s_ped2_path <- file.path(s_data_root, "lbgfs2022_exam_problem2_pedigree2.csv")
tbl_ped2_p02 <- readr::read_delim(s_ped2_path, 
                                  delim = ",",
                                  col_types = readr::cols(
                                    id = readr::col_character(),
                                    sire = readr::col_character(),
                                    dam = readr::col_character(),
                                    AgeOwner = readr::col_double()
                                  ))
```

### Breed 1:

```{r, echo=FALSE, prompt=FALSE}
cat(s_ped1_path, "\n")
knitr::kable(tbl_ped1_p02, booktabs = TRUE, longtable = TRUE)
```


### Breed 2:

```{r, echo=FALSE, prompt=FALSE}
cat(s_ped2_path, "\n")
knitr::kable(tbl_ped2_p02, booktabs = TRUE, longtable = TRUE)
```

\clearpage
\pagebreak

```{=tex}
\begin{enumerate}
\item[a)] Setup the numerator relationship matrices for both breeds given above. 

\textit{Stellen Sie die additiv genetischen Verwandtschaftsmatrizen für beide oben gegebenen Rassen auf.}
\points{`r lPointsQ2$TaskA`}
\end{enumerate}
```

\vspace{3ex}
\solstart

\textbf{Breed 1}

Reading the data

```{r}
tbl_ped1 <- readr::read_delim(file = s_ped1_path,
                              delim = ",",
                              col_types = readr::cols(
                                Animal = readr::col_character(),
                                Sire = readr::col_character(),
                                Dam = readr::col_character(),
                                AgeOwner = readr::col_double()
                              ))
```

Adding founder animals to the pedigree

```{r}
vec_sire_founder <- unique(tbl_ped1$Sire)
vec_sire_founder <- vec_sire_founder[!is.element(vec_sire_founder, tbl_ped1$Animal)]
vec_dam_founder <- unique(tbl_ped1$Dam)
vec_dam_founder <- vec_dam_founder[!is.element(vec_dam_founder, tbl_ped1$Animal)]
vec_founder <- c(vec_sire_founder, vec_dam_founder)
n_nr_founder <- length(vec_founder)
tbl_ped1_founder <- tibble::tibble(Animal = vec_founder, 
                                   Sire = rep(NA, n_nr_founder), 
                                   Dam = rep(NA, n_nr_founder), 
                                   AgeOwner = rep(NA, n_nr_founder))
tbl_ped1_aug <- dplyr::bind_rows(tbl_ped1_founder, tbl_ped1)
```

Remapping the IDs to integer values

```{r}
tbl_ped_ID_map <- tibble::tibble(DomainCharId = tbl_ped1_aug$Animal,
                                 ImageIntId = c(1:length(tbl_ped1_aug$Animal)))
library(dplyr)
# Animals
tbl_ped1_int_id <- tbl_ped1_aug %>%
  left_join(tbl_ped_ID_map, by = c("Animal" = "DomainCharId")) %>%
  rename(AnimalIntId = ImageIntId)
# Sire
tbl_ped1_int_id <- tbl_ped1_int_id %>%
  left_join(tbl_ped_ID_map, by = c("Sire" = "DomainCharId")) %>%
  rename(SireIntId = ImageIntId)
# Dam 
tbl_ped1_int_id <- tbl_ped1_int_id %>%
  left_join(tbl_ped_ID_map, by = c("Dam" = "DomainCharId")) %>%
  rename(DamIntId = ImageIntId)
```

Get the numerator relationship matrix with `pedigreemm`

```{r}
ped_ped1 <- pedigreemm::pedigree(sire = tbl_ped1_int_id$SireIntId, 
                                 dam =  tbl_ped1_int_id$DamIntId,
                                 label = as.character(tbl_ped1_int_id$AnimalIntId))
mat_A_ped1 <- as.matrix(pedigreemm::getA(ped = ped_ped1))
```

The numerator relationship matrix $A_1$ for the pedigree of breed 1 is

```{r, echo=FALSE}
# rmdhelp::bmatrix(pmat = mat_A_ped1, ps_name = "A", ps_env = "$$")
mat_A_ped1
```


\textbf{Breed 2}

Reading the data

```{r}
tbl_ped2 <- readr::read_delim(file = s_ped2_path,
                              delim = ",",
                              col_types = readr::cols(
                                Animal = readr::col_character(),
                                Sire = readr::col_character(),
                                Dam = readr::col_character(),
                                AgeOwner = readr::col_double()
                              ))
```

Adding founder animals to the pedigree

```{r}
vec_sire_founder <- unique(tbl_ped2$Sire)
vec_sire_founder <- vec_sire_founder[!is.element(vec_sire_founder, tbl_ped2$Animal)]
vec_dam_founder <- unique(tbl_ped2$Dam)
vec_dam_founder <- vec_dam_founder[!is.element(vec_dam_founder, tbl_ped2$Animal)]
vec_founder <- c(vec_sire_founder, vec_dam_founder)
n_nr_founder <- length(vec_founder)
tbl_ped2_founder <- tibble::tibble(Animal = vec_founder, 
                                   Sire = rep(NA, n_nr_founder), 
                                   Dam = rep(NA, n_nr_founder), 
                                   AgeOwner = rep(NA, n_nr_founder))
tbl_ped2_aug <- dplyr::bind_rows(tbl_ped2_founder, tbl_ped2)
```

Remapping the IDs to integer values

```{r}
tbl_ped_ID_map <- tibble::tibble(DomainCharId = tbl_ped2_aug$Animal,
                                 ImageIntId = c(1:length(tbl_ped2_aug$Animal)))
library(dplyr)
# Animals
tbl_ped2_int_id <- tbl_ped2_aug %>%
  left_join(tbl_ped_ID_map, by = c("Animal" = "DomainCharId")) %>%
  rename(AnimalIntId = ImageIntId)
# Sire
tbl_ped2_int_id <- tbl_ped2_int_id %>%
  left_join(tbl_ped_ID_map, by = c("Sire" = "DomainCharId")) %>%
  rename(SireIntId = ImageIntId)
# Dam 
tbl_ped2_int_id <- tbl_ped2_int_id %>%
  left_join(tbl_ped_ID_map, by = c("Dam" = "DomainCharId")) %>%
  rename(DamIntId = ImageIntId)
```

Get the numerator relationship matrix with `pedigreemm`

```{r}
ped_ped2 <- pedigreemm::pedigree(sire = tbl_ped2_int_id$SireIntId, 
                                 dam =  tbl_ped2_int_id$DamIntId,
                                 label = as.character(tbl_ped2_int_id$AnimalIntId))
mat_A_ped2 <- as.matrix(pedigreemm::getA(ped = ped_ped2))
```

The numerator relationship matrix $A_2$ for the pedigree of breed 2 is

```{r, echo=FALSE}
# rmdhelp::bmatrix(pmat = mat_A_ped2, ps_name = "A", ps_env = "$$")
mat_A_ped2
```

\solend

```{=tex}
\clearpage
\pagebreak
```
```{=tex}
\begin{enumerate}
\item[b)] Compute the inbreeding coefficients for all animals in both pedigrees of the two breeds given above. 

\textit{Berechnen Sie die Inzuchtkoeffizienten für alle Tiere in beiden Pedigrees der zwei Rassen, welche oben gegeben sind.}
\points{`r lPointsQ2$TaskB`}
\end{enumerate}
```
```{=tex}
\vspace{3ex}
\solstart
```

\textbf{Breed 1}

Inbreeding coefficients of animals are

```{r}
tbl_inb1 <- tibble::tibble(Animal = tbl_ped1_aug$Animal,
                           `Inbreeding Coefficients` = diag(mat_A_ped1) - 1)
```

The results of the inbreeding coefficients of all animals are shown in the following table

```{r, echo=FALSE}
knitr::kable(tbl_inb1, booktabs = TRUE, longtable = TRUE)
```


\textbf{Breed 2}

Inbreeding coefficients of animals are

```{r}
tbl_inb2 <- tibble::tibble(Animal = tbl_ped2_aug$Animal,
                           `Inbreeding Coefficients` = diag(mat_A_ped2) - 1)
```

The results of the inbreeding coefficients of all animals are shown in the following table

```{r, echo=FALSE}
knitr::kable(tbl_inb2, booktabs = TRUE, longtable = TRUE)
```

\solend

```{=tex}
\clearpage
\pagebreak
```

```{r, echo=FALSE}
n_weight_AvInb <- 1
n_weight_AvAge <- 0.002
```

```{=tex}
\begin{enumerate}
\item[c)] For our example breeds, we use a simplified version of the index ($I_E$) indicating which breeds are endangered. This version of the index is based on the average inbreeding coefficients of all animals in a given breed and on the average age of the owners of the animals in that breed. Compute for both given breeds the index $I_E$ using a weight $w_F = `r n_weight_AvInb`$ for the average inbreeding coefficient and a weight $w_O = `r n_weight_AvAge`$ for the average age of the owners of the animals. The index can be computed as shown below. Determine based on the value of the index for both breeds which breed is considered to be more endangered.

\textit{Für die zwei Beispielrassen wird eine vereinfachte Form des Gefährungsindexes} $I_E$ \textit{ berechnet. Diese Version des Indexes basiert auf dem durchschnittlichen Inzuchtkoeffizienten aller Tiere im Pedigree und auf dem durchschnittlichen Alter der Tierhalter einer bestimmten Rasse. Berechnen Sie für beide gegebenen Rassen den index } $I_E$ \textit{ mit den Gewichten } $w_F = `r n_weight_AvInb`$ \textit{ für den durchschnittlichen Inzuchtkoeffizient und } $w_O = `r n_weight_AvAge`$ \textit{ für das durchschnittliche Alter der Tierhalter. Der Index kann wie nachfolgend gezeigt berechent werden. Entscheiden Sie basierend auf dem Indexwert für beide Rassen, welche Rasse als gefährdeter eingestuft würde.}
\points{`r lPointsQ2$TaskC`}
\end{enumerate}
```

For a given breed the endangerment index $I_E$ is computed as

\textit{Für eine bestimmte Rasse kann der Gefährdungsindex } $I_E$ \textit{ wie folgt berechnet werden}

$$I_E = w_F * \bar{F} + w_O * \bar{O}$$

where $\bar{F}$ is the average inbreeding coefficient of all animals in the pedigree and $\bar{O}$ is the average age of all owners of animals of a given breed.



```{=tex}
\vspace{3ex}
\solstart
```

\textbf{Breed 1}

```{r}
vec_av_inb1 <- mean(diag(mat_A_ped1) - 1)
vec_av_age1 <- mean(tbl_ped1$AgeOwner)
n_index_e1 <- n_weight_AvInb * vec_av_inb1 + n_weight_AvAge * vec_av_age1
```

$$I_E = `r n_weight_AvInb` * `r vec_av_inb1` + `r n_weight_AvAge` * `r vec_av_age1` =  `r n_index_e1`$$


\textbf{Breed 2}

```{r}
vec_av_inb2 <- mean(diag(mat_A_ped2) - 1)
vec_av_age2 <- mean(tbl_ped2$AgeOwner)
n_index_e2 <- n_weight_AvInb * vec_av_inb2 + n_weight_AvAge * vec_av_age2
```

$$I_E = `r n_weight_AvInb` * `r vec_av_inb2` + `r n_weight_AvAge` * `r vec_av_age2` =  `r n_index_e2`$$

Based on the much higher average age of the owners of the animals in breed 1, breed 1 is considered to be more endangered.

\solend

```{=tex}
\clearpage
\pagebreak
```
```{r, echo=FALSE, results='asis'}
cat(cnt$out(ps_suffix = "Genomics"), "\n")
```

```{r, echo=FALSE}
s_pr03_data_path <- file.path(s_data_root, "lbgfs2022_exam_problem3.csv")
tbl_pr3 <- readr::read_delim(s_pr03_data_path, 
                             delim = ",",
                             col_types = readr::cols(
                               sex = readr::col_factor(),
                               y = readr::col_double(),
                               .default = readr::col_integer()
                             ))
n_nr_loci <- length(grep("S", colnames(tbl_pr3)))
lambda_mem <- 1
```


The following dataset is used to predict genomic breeding values. The column `y` contains the observations and columns `S1` to `S15` contain genotypes of `r n_nr_loci` SNP marker loci.

\textit{Der folgende Datensatz wird für die Schätzung genomischer Zuchtwerte verwendet. Die Kolonne } \verb+y+ \textit{ enthält die beobachteten Merkmalswerte und die Kolonnen } \verb+S1+ \textit{ bis } \verb+S15+ \textit{ enthalten die Genotypen von } `r n_nr_loci` SNP-Marker. 

```{r, echo=FALSE}
knitr::kable(tbl_pr3, booktabs = TRUE, longtable = TRUE)
```

The above dataset is available under:

\textit{Der oben gezeigte Datensatz ist verfügbar unter:}

```{r, echo=FALSE}
cat(s_pr03_data_path, "\n")
```

\vspace{3ex}
\begin{enumerate}
\item[a)] Use a marker effect model (MEM) to predict genomic breeding values for the animals given in the dataset shown above. Specify the marker effect model as a mathematical formula and list the meaning of all model components. Indicate the expected values and the variance-covariance matrices for all random effects in the model. You can assume $\lambda = \sigma_e^2 / \sigma_q^2 = `r lambda_mem`$.

\textit{Verwenden Sie ein Marker-Effekt-Modell (MEM) zur Schätzung der genomischen Zuchtwerte für die Tiere im oben gezeigten Datensatz. Spezifizieren Sie das Marker-Effekt-Modell als mathematische Formel und notieren Sie die Bedeutung aller Modellkomponenten. Geben Sie die Erwartungswerte und die Varianz-Kovarianz-Matrizen aller zufälligen Effekte an. Wir nehmen an, dass } $\lambda = \sigma_e^2 / \sigma_q^2 = `r lambda_mem`$.
\points{`r lPointsQ3$TaskA`}
\end{enumerate}

\solstart
Read the data

```{r}
s_pr03_data_path <- file.path(s_data_root, "lbgfs2022_exam_problem3.csv")
tbl_pr3 <- readr::read_delim(s_pr03_data_path, 
                             delim = ",",
                             col_types = readr::cols(
                               sex = readr::col_factor(),
                               y = readr::col_double(),
                               .default = readr::col_integer()
                             ))
n_nr_animal <- nrow(tbl_pr3)
n_nr_loci <- length(grep("S", colnames(tbl_pr3)))
```

Set up a marker effect model which in this case has to be a linear mixed effect model

$$y = X\beta + Wq + e$$

with $\beta^T = \left[ \begin{array}{cc} \beta_M & \beta_F \end{array} \right]$ the vector of fixed sex effects, $q$ the vector of random marker effects, $e$ the vector of random residuals and $y$ the vector of observations. $X$ is the design matrix linking fixed effects to observations. The matrix $W$ contains the genotypes in a $-1,0,1$ encoding. 

The expected values and the variance-covariance matrices for all random effects are

$$
E\left[ \begin{array}{c}y \\ q \\ e \end{array}\right] = \left[ \begin{array}{c} X\beta \\ 0 \\ 0 \end{array}\right] \text{, }
var\left[ \begin{array}{c}y \\ q \\ e \end{array}\right] = \left[ \begin{array}{ccc} WW^T \sigma_q^2 + R &  W \sigma_q^2 & R  \\ W^T \sigma_q^2 & I \sigma_q^2 & 0 \\ R & 0 & R \end{array}\right]
$$
with $R = I\sigma_e^2$. The components $\sigma_e^2$ and $\sigma_q^2$ are the residual variance components and the marker variance components.

Design matrix for fixed effects

```{r}
# info from dataset to model component
vec_y <- tbl_pr3$y
# design matrix for fixed effects
mat_X <- model.matrix(lm(y ~ 0 + sex, data = tbl_pr3))
attr(mat_X, "assign") <- NULL
attr(mat_X, "contrasts") <- NULL
colnames(mat_X) <- NULL
mat_X
```

Genotype Matrix

```{r}
tbl_SNP <- dplyr::select(tbl_pr3, dplyr::starts_with("S", ignore.case = FALSE))
mat_W <- as.matrix(tbl_SNP) - 1
colnames(mat_W) <- NULL
mat_W
```

Mixed model equations

```{r}
lambda_mem <- 1
mat_xtx <- crossprod(mat_X)
mat_xtw <- crossprod(mat_X, mat_W)
mat_wtx <- t(mat_xtw)
mat_wtwlI <- crossprod(mat_W) + lambda_mem * diag(nrow = n_nr_loci)
mat_coef <- rbind(cbind(mat_xtx,mat_xtw),cbind(mat_wtx,mat_wtwlI))
mat_rhs <- rbind(crossprod(mat_X, vec_y),
                 crossprod(mat_W, vec_y))
mat_sol <- solve(mat_coef,mat_rhs)
mat_sol
```

The genomic breeding values are computed as

```{r}
vec_marker_sol <- mat_sol[3:(nrow(mat_sol)),1]
tbl_mem_dgw <- tibble::tibble(Animal = c(1:n_nr_animal),
                              `Genomic BV`= crossprod(t(mat_W), vec_marker_sol))
knitr::kable(tbl_mem_dgw, booktabs = TRUE, longtable = TRUE)
```

Rank animals according to the DGW

```{r}
order(tbl_mem_dgw$`Genomic BV`, decreasing = TRUE)
```

\solend

```{=tex}
\clearpage
\pagebreak
```

```{r, echo=FALSE}
lambda_bvm <- 3
```

```{=tex}
\begin{enumerate}
\item[b)] Predict genomic breeding values using a breeding value based model (BVM) for all animals in the above given dataset. Specify the model as a mathematical formula and list the meaning of all model components. Indicate the expected values and the variance-covariance matrices for all random effects in the model. You can assume $\lambda = \sigma_e^2 / \sigma_g^2 = `r lambda_bvm`$.

\textit{Schätzen Sie genomische Zuchtwerte mit einem Zuchtwert-basierten Modell (BVM) für alle Tiere im oben gezeigten Datensatz. Spezifizieren Sie das Modell als mathematische Formel und notieren Sie die Bedeutung aller Modellkomponenten. Geben Sie die Erwartungswerte und die Varianz-Kovarianz-Matrizen aller zufälligen Effekte an. Wir nehmen an, dass } $\lambda = \sigma_e^2 / \sigma_g^2 = `r lambda_bvm`$.
\points{`r lPointsQ3$TaskB`}
\end{enumerate}
```

\solstart
We assume that the dataset is read as shown in the solution of 3a). Futhermore the definition of the number of animals and the number of loci are executed.

The breeding value based model is

$$y = X\beta + Zg + e$$

with $\beta^T = \left[ \begin{array}{cc} \beta_M & \beta_F \end{array} \right]$ the vector of fixed sex effects, $g$ the vector of random genomic breeding values, $e$ the vector of random residuals and $y$ the vector of observations. $X$ is the design matrix linking fixed effects to observations. The matrix $Z$ is the design matrix linking genomic breeding values to observations. 

The expected values and the variance-covariance matrices for all random effects are

$$
E\left[ \begin{array}{c}y \\ g \\ e \end{array}\right] = \left[ \begin{array}{c} X\beta \\ 0 \\ 0 \end{array}\right] \text{, }
var\left[ \begin{array}{c}y \\ g \\ e \end{array}\right] = \left[ \begin{array}{ccc} ZHZ^T + R &  ZH & R  \\ HZ^T & H & 0 \\ R & 0 & R \end{array}\right]
$$
with $R = I\sigma_e^2$ and $H = G*\sigma_g^2$. The matrix $G$ is the genomic relationship matrix and $\sigma_e^2$ and $\sigma_g^2$ are the residual and the genetic variance components.

Design matrix $X$ for fixed effects

```{r}
# info from dataset to model component
vec_y <- tbl_pr3$y
# design matrix for fixed effects
mat_X <- model.matrix(lm(y ~ 0 + sex, data = tbl_pr3))
attr(mat_X, "assign") <- NULL
attr(mat_X, "contrasts") <- NULL
colnames(mat_X) <- NULL
mat_X
```

Design matrix $Z$ for the genomic breeding values

```{r}
mat_Z <- diag(nrow = n_nr_animal)
mat_Z
```

The genomic relationship matrix is computed using the following function

```{r}
#' Compute genomic relationship matrix based on data matrix
computeMatGrm <- function(pmatData, pn_max_iter = 10, pn_min_eig_val = 0.0001) {
  matData <- pmatData
  # check the coding, if matData is -1, 0, 1 coded, then add 1 to get to 0, 1, 2 coding
  if (min(matData) < 0) matData <- matData + 1
  # Allele frequencies, column vector of P and sum of frequency products
  freq <- apply(matData, 2, mean) / 2
  P <- 2 * (freq - 0.5)
  sumpq <- sum(freq*(1-freq))
  # Changing the coding from (0,1,2) to (-1,0,1) and subtract matrix P
  Z <- matData - 1 - matrix(P, nrow = nrow(matData), 
                             ncol = ncol(matData), 
                             byrow = TRUE)
  # Z%*%Zt is replaced by tcrossprod(Z)
  matG_result <- tcrossprod(Z)/(2*sumpq)
  # check for positive definiteness
  n_min_eig_matG_result <- min(eigen(matG_result, only.values = TRUE)$values)
  n_iter_idx <- 0
  while (n_min_eig_matG_result < pn_min_eig_val & n_iter_idx < pn_max_iter){
    matG_result <- matG_result + 0.01 * diag(nrow = nrow(matG_result))
    n_min_eig_matG_result <- min(eigen(matG_result, only.values = TRUE)$values)
    n_iter_idx <- n_iter_idx + 1
  }
  # check for convergence
  if (n_iter_idx > pn_max_iter){
    stop(" *** ERROR: No convergence of bending genomic relationship matrix")
  }
  return(matG_result)
}
```

For our dataset the genomic relationship matrix $G$ is

```{r}
tbl_SNP <- dplyr::select(tbl_pr3, dplyr::starts_with("S", ignore.case = FALSE))
mat_W <- as.matrix(tbl_SNP) - 1
colnames(mat_W) <- NULL
mat_G <- computeMatGrm(pmatData = mat_W)
mat_G
```

The mixed model equations

```{r}
lambda_bvm <- 3
mat_xtx <- crossprod(mat_X)
mat_xtz <- crossprod(mat_X, mat_Z)
mat_ztx <- crossprod(mat_Z, mat_X)
stopifnot(min(mat_ztx - t(mat_xtz)) == 0)
stopifnot(max(mat_ztx - t(mat_xtz)) == 0)
mat_ztz_lGinv <- crossprod(mat_Z) + lambda_bvm * solve(mat_G)
# coefficient matrix
mat_coef <- rbind(cbind(mat_xtx,mat_xtz),cbind(mat_ztx,mat_ztz_lGinv))
# rhs
mat_rhs <- rbind(crossprod(mat_X, vec_y),
                 crossprod(mat_Z, vec_y))
# solve
mat_sol <- solve(mat_coef, mat_rhs)
mat_sol
```

The solutions for the estimates of the fixed effects are

```{r}
mat_sol[1:2,]
```

The solutions for the predicted breeding values are

```{r}
tbl_pred_bv <- tibble::tibble(Animal = c(1:n_nr_animal),
                              `Predicted Genomic BV` = mat_sol[3:(nrow(mat_sol)),1])
knitr::kable(tbl_pred_bv)
```

The ranking of the animals according to the predicted genomic breeding values are

```{r}
order(tbl_pred_bv$`Predicted Genomic BV`, decreasing = TRUE)
```


\solend

```{=tex}
\clearpage
\pagebreak
```
```{=tex}
\vspace{3ex}
\begin{enumerate}
\item[c)]  Compare the order of the predicted breeding values of all animals based on the marker effect model (MEM) and based on the breeding value model (BVM)

\textit{Vergleichen Sie die Reihenfolge der Tiere aufgrund der geschätzten genomischen Zuchtwerte basierend auf dem Markereffektmodell (MEM) und basierend auf dem Zuchtwert-basierten Modell (BVM)}
\points{`r lPointsQ3$TaskC`}
\end{enumerate}
```
\solstart

```{r}
order(tbl_mem_dgw$`Genomic BV`, decreasing = TRUE)
```

```{r}
order(tbl_pred_bv$`Predicted Genomic BV`, decreasing = TRUE)
```

\solend

```{=tex}
\clearpage
\pagebreak
```
```{r, echo=FALSE, results='asis'}
cat(cnt$out(ps_suffix = "BLUP Animal Model"), "\n")
```

```{r, echo=FALSE}
n_sigma_p2 <- 64
n_h2 <- 0.16
s_data_p04_url <- file.path(s_data_root, "lbgfs2022_exam_problem4.csv")
tbl_data_p04_read <- readr::read_delim(s_data_p04_url, 
                                       delim = ",",
                                       col_types = readr::cols(
                                         y = readr::col_double(),
                                         .default = readr::col_integer()
                                       ))
n_nr_obs <- nrow(tbl_data_p04_read)
```


```{r, echo=FALSE}
knitr::kable(tbl_data_p04_read, booktabs = TRUE, longtable = TRUE)
```

The above dataset is available under: 

\textit{Der oben gezeigte Datensatz ist verfügbar unter:}

```{r, echo=FALSE}
cat(s_data_p04_url, "\n")
```


\vspace{3ex}
\begin{enumerate}
\item[a)]  Use the above shown dataset to predict breeding values for all animals in the pedigree using a BLUP animal model. Use `herd` as fixed effect and compute estimates for all the levels of the fixed effect. The column entitled `y` contains the values for an observed trait of interest. Specify the model as mathematical formula and list the meaning of all model components. Write down the expected values and the variance-covariance matrices for all random effects in the model. Assume the phenotypic variance to be $\sigma_p^2 = `r n_sigma_p2`$ and the heritability to be $h^2 = `r n_h2`$.

\textit{Verwenden Sie den oben gezeigten Datensatz für die Schätzung von Zuchtwerten für alle Tiere im Pedigree mit einem BLUP-Tiermodell. Modellieren Sie } \verb+herd+ \textit{als fixen Effekt. Berechnen Sie Schätzwerte für alle Stufen des fixen Effekts. Die Kolonne mit dem Titel} \verb+y+ \textit{enthält die Beobachtungswerte eines Merkmals von züchterischem Interesse. Spezifizieren Sie das Modell als mathematische Formel und benennen Sie die Bedeutung jeder Modellkomponente. Notieren Sie die Erwartungswerte und die Varianz-Kovarianzmatrizen aller zufälligen Effekte im Modell. Die phänotypische Varianz wird angenommen als } $\sigma_p^2 = `r n_sigma_p2`$ \textit{ und die Erblichkeit sei } $h^2 = `r n_h2`$.
\points{`r lPointsQ4$TaskA`}
\end{enumerate}

\solstart

The BLUP animal model is

$$y = X\beta + Zu + e$$

with $\beta^T = \left[ \begin{array}{ccc} \beta_{h1} & \beta_{h2} & \beta_{h3} \end{array} \right]$ the vector of fixed herd effects, $u$ the vector of random breeding values, $e$ the vector of random residuals and $y$ the vector of observations. $X$ is the design matrix linking fixed effects to observations. The matrix $Z$ is the design matrix linking the breeding values to observations. 

The expected values and the variance-covariance matrices for all random effects are

$$
E\left[ \begin{array}{c}y \\ u \\ e \end{array}\right] = \left[ \begin{array}{c} X\beta \\ 0 \\ 0 \end{array}\right] \text{, }
var\left[ \begin{array}{c}y \\ u \\ e \end{array}\right] = \left[ \begin{array}{ccc} ZGZ^T + R &  ZG & R  \\ GZ^T & G & 0 \\ R & 0 & R \end{array}\right]
$$
with $R = I\sigma_e^2$ and $G = A*\sigma_g^2$. The matrix $A$ is the numerator relationship matrix and $\sigma_e^2$ and $\sigma_u^2$ are the residual and the genetic variance components.

Design matrix $X$ for fixed effects

```{r}
mat_X <- model.matrix(lm(y ~ 0 + as.factor(herd), data = tbl_data_p04_read))
attr(mat_X, "assign") <- NULL
attr(mat_X, "contrasts") <- NULL
colnames(mat_X) <- NULL
mat_X
```

The pedigree

```{r}
vec_founder_sire <- 
  unique(tbl_data_p04_read$sire[!is.element(tbl_data_p04_read$sire, 
                                            tbl_data_p04_read$id)])
vec_founder_dam <- 
  unique(tbl_data_p04_read$dam[!is.element(tbl_data_p04_read$dam, 
                                           tbl_data_p04_read$id)])
vec_founder_cmb <- c(vec_founder_sire, vec_founder_dam)
n_nr_founder <- length(vec_founder_cmb)
tbl_ped_aug <- dplyr::bind_rows(tibble::tibble(id = vec_founder_cmb, 
                                               sire = rep(NA, n_nr_founder), 
                                               dam = rep(NA, n_nr_founder)),
                                dplyr::select(tbl_data_p04_read, id, sire, dam))
n_nr_ani_ped <- nrow(tbl_ped_aug)
```

The inverse numerator relationship matrix

```{r}
ped_p04 <- pedigreemm::pedigree(sire = as.integer(tbl_ped_aug$sire),
                                dam  = as.integer(tbl_ped_aug$dam),
                                label = tbl_ped_aug$id)
mat_A_inv_p04 <- as.matrix(pedigreemm::getAInv(ped = ped_p04))
```

Design matrix $Z$ for the random breeding values

```{r}
mat_Z <- cbind(matrix(0, nrow = n_nr_obs, ncol = n_nr_founder), diag(nrow = n_nr_obs))
mat_Z
```

The mixed model equations

```{r}
# genetic parameter
n_sigma_u2 <- n_h2 * n_sigma_p2
n_sigma_e2 <- n_sigma_p2 - n_sigma_u2
n_lambda <- n_sigma_e2 / n_sigma_u2
# mme components
vec_y_read <- tbl_data_p04_read$y
mat_xtx <- crossprod(mat_X)
mat_xtz <- crossprod(mat_X, mat_Z)
mat_ztx <- crossprod(mat_Z, mat_X)
stopifnot(min(mat_ztx - t(mat_xtz)) == 0)
stopifnot(max(mat_ztx - t(mat_xtz)) == 0)
mat_ztzlAinv <- crossprod(mat_Z) + n_lambda * mat_A_inv_p04
mat_coef <- rbind(cbind(mat_xtx,mat_xtz), cbind(mat_ztx,mat_ztzlAinv))
# rhs
mat_rhs <- rbind(crossprod(mat_X, vec_y_read),
                 crossprod(mat_Z, vec_y_read))
# sol
mat_sol <- solve(mat_coef, mat_rhs)
```

The estimates for the fixed herd effects are 

```{r}
n_nr_herd_levels <- ncol(mat_X)
mat_sol[1:n_nr_herd_levels,]
```

The predicted breeding values are

```{r}
mat_sol[(n_nr_herd_levels+1):(nrow(mat_sol)),]
```

\solend

\clearpage
\pagebreak

\begin{enumerate}
\item[b)] Compute the reliabilities for the predicted breeding values of all animals under Problem 4a).

\textit{Berechnen Sie die Bestimmtheitsmasse der unter Aufgabe 4a) geschätzten Zuchterte.}
\points{`r lPointsQ4$TaskB`}
\end{enumerate}

\solstart

```{r}
n_nr_herd_levels <- ncol(mat_X)
mat_coef_full <- mat_coef / n_sigma_e2
vec_pev <- diag(solve(mat_coef_full))[(n_nr_herd_levels+1):nrow(mat_coef)]
mat_A_p04 <- as.matrix(pedigreemm::getA(ped = ped_p04))
vec_A_diag <- diag(mat_A_p04)
vec_rel <- 1 - (vec_pev / (n_sigma_u2 * vec_A_diag))
vec_rel
```

\solend


\clearpage
\pagebreak


```{r, echo=FALSE, results='asis'}
cat(cnt$out(ps_suffix = "Variance and Inbreeding"), "\n")
```

```{r prob1-prepare,echo=FALSE}
n_exile_year <- 1892
n_export_year <- 2022
n_total_nr_sheep <- 2200
n_nr_subpop <- 4
n_nr_female_per_male <- 10
n_gen_interval <- 1.3
# compute derived quantities
n_total_nr_female <- n_total_nr_sheep / (n_nr_female_per_male + 1) * n_nr_female_per_male
n_total_nr_female_per_subpop <- n_total_nr_female / n_nr_subpop
n_nr_gen <- (n_export_year - n_exile_year) / n_gen_interval
n_delta_F <- 1 / (2 * n_total_nr_female_per_subpop)
```



In the year `r n_exile_year` a group of Scottish farmers landed with their sheep in Australia. The farmers took a total of `r n_total_nr_sheep` sheeps from Scotland to Australia. Once the farmers arrived in Australia, they separated in `r n_nr_subpop` subgroups of equal sizes. Each of the subgroups went to a different state of Australia (Western Australia, North Australia, New South Wales and South Australia). In the year `r n_export_year` Australian sheep farmers want to export some of their breeding animals. For this problem you can work with the following assumptions

* There was no exchange of animals between the sub-populations after the split into subgroups. 
* The ratio between the number of female animals and the number of male animals is `r n_nr_female_per_male`.
* The size of the sub-populations $N$ which is relevant for the computation of the inbreeding coefficient is set to the number of female animals in each sub-population.
* The generation interval can assumed to be `r n_gen_interval` years. 

\textit{Im Jahr `r n_exile_year` wanderte eine Gruppe von Schottischen Farmern mit ihren Schafen nach Australien aus. Die Farmer brachten `r n_total_nr_sheep` Schafe nach Australien. Als die Farmer in Australien ankamen teilten sie sich in `r n_nr_subpop` gleich grosse Gruppen auf. Jede Gruppe ging in einen anderen Staat in Australien (Western Australia, North Australia, New South Wales and South Australia). Im Jahr `r n_export_year` möchten die Farmer einige ihrer Zuchttiere exportieren. Für diese Aufgabe können Sie die folgenden Annahmen treffen.}

* \textit{Nach der Aufteilung der Tiere in die Gruppen kam es zu keinem Tieraustausch zwischen den Gruppen.}
* \textit{Das Verhältnis zwischen der Anzahl weiblicher Tiere und der Anzahl männlicher Tiere beträgt `r n_nr_female_per_male`.}
* \textit{Die Popultationsgrösse $N$, welche für die Berechnung des Inzuchtkoeffizienten wichtig ist, kann mit der Anzahl weiblichen Tiere in jeder Subpopulation gleichgesetzt werden.}
* \textit{Das Generationeninterval betrage `r n_gen_interval` Jahre.}


```{r fig-sub-pop, echo=FALSE, hook_convert_odg=TRUE, fig_path="odg"}
#rmdhelp::use_odg_graphic(ps_path = "odg/fig-sub-pop.odg")
knitr::include_graphics(path = "odg/fig-sub-pop.png")
```


\vspace{3ex}

```{=tex}
\begin{enumerate}
\item[a)] Compute the inbreeding coefficient $F_t$ for the breeding animals that the farmers want to sell. 

\textit{Berechnen Sie den Inzuchtkoeffizienten $F_t$ für die Zuchttiere, welche die Farmer verkaufen möchten.}
\points{`r lPointsQ5$TaskA`}
\end{enumerate}
```

\solstart

The inbreeding coefficient $F_t$ is computed as

$$F_t = 1 - (1 - \Delta F)^t$$
where $\Delta F$ corresponds to $1/(2N)$ and $t$ is equal to the number of generations. Inserting the number leads to

```{r prob1a-sol, echo=FALSE}
n_F_t <- 1 - (1 - n_delta_F)^n_nr_gen
```

$$F_t = 1 - (1 - `r n_delta_F`)^{`r n_nr_gen`} = `r round(n_F_t, digits = 4)`$$

\solend

```{=tex}
\clearpage
\pagebreak
```

```{r prob1b-prepare, echo=FALSE}
n_F_t_limit <- 0.1
```

```{=tex}
\begin{enumerate}
\item[b)] The sheep farmers are concerned that inbreeding in their population does not increase too much. In which year is the inbreeding coefficient $F_t$ going to be bigger than `r n_F_t_limit`?

\textit{Die Farmer möchten den Inzuchtgrad nicht zu stark ansteigen lassen. In welchem Jahr wird der Inzuchtgrad $F_t$ grösser sein als `r n_F_t_limit`?}
\points{`r lPointsQ5$TaskB`}
\end{enumerate}
```

\solstart

```{r prob1b-sol, echo=FALSE}
n_nr_gen_limit <- (log(1 - n_F_t_limit))/ (log(1 - n_delta_F))
n_nr_gen_limit_round <- ceiling(n_nr_gen_limit)
n_limit_year <- n_exile_year + n_nr_gen_limit_round * n_gen_interval
n_limit_year_rounded <- ceiling(n_limit_year)
```

We are given the limit of $F_t$ and we want to know the value for $t$ when this limit is reached. Hence we have to solve the equation for $F_t$ after $t$. Hence 

\begin{align}
F_t  &=  1 - (1 - \Delta F)^t \notag \\
(1 - \Delta F)^t  &=  1 - F_t \notag \\
t  &=  \frac{log(1 - F_t)}{log(1 - \Delta F)}  \notag \\
   &=  \frac{log(1 - `r n_F_t_limit`)}{log(1 - `r n_delta_F`)} = `r n_nr_gen_limit`  \notag 
\end{align}

This means after `r n_nr_gen_limit_round` generations the limit is reached. With a generation interval of `r n_gen_interval` years, this will be the limit of the inbreeding coefficient will be reached in the year `r n_limit_year_rounded`. 

\solend

```{=tex}
\clearpage
\pagebreak
```

```{r prob1c-prepare, echo=FALSE}
n_maf_locus_w <- 0.045
n_homo_geno_val <- 50
n_het_geno_val <- 15
```

```{=tex}
\begin{enumerate}
\item[c)] One reason to control the inbreeding coefficient is that breeders want to avoid inbreeding depression. We assume that locus $W$ is mainly responsible for wool fibre diameter (FD). The favorable allele $W_1$ occurs with a frequency of $p = `r n_maf_locus_w`$. The difference between the homozygous genotypes $W_1W_1$ and $W_2W_2$ in fiber diameter is $`r 2*n_homo_geno_val`$ micrometer ($\mu m$). The genotypic value of the heterozygous genotype $W_1W_2$ is `r n_het_geno_val`. Compute the inbreeding depression at locus $W$, if the inbreeding coefficient has reached the limiting value of Problem 1b of `r n_F_t_limit`.

\textit{Züchter wollen die Inzucht begrenzen, da sie Inzuchtdepressionen vermeiden wollen. Wir nehmen an, dass das Merkmal Wollfaserdurchmesser hauptsächlich von einem Genort $W$ beeinflusst wird. Das vorteilhafte Allel $W_1$ kommt mit einer Häufigkeit von $p = `r n_maf_locus_w`$ vor. Die Differenz zwischen den homozygoten Genotypen $W_1W_1$ und $W_2W_2$ im Merkmal Wollfaserdurchmesser beträgt $`r 2*n_homo_geno_val`$ Mikrometer ($\mu m$). Der genotypische Wert der Heterozygoten $W_1W_2$ beträgt `r n_het_geno_val`. Berechnen Sie die Inzuchtdepression am Genort $W$ unter der Annahme, dass der Inzuchtkoeffizient den Grenzwert aus Aufgabe 1b von `r n_F_t_limit` erreicht hat.}
\points{`r lPointsQ5$TaskC`}
\end{enumerate}
```

\vspace{3ex}
\solstart
The inbreeding depression is computed as

```{r prob1c-sol, echo=FALSE}
n_inb_depr <- 2 * n_het_geno_val * n_maf_locus_w * (1-n_maf_locus_w) * n_F_t_limit
n_inb_depr_rounded <- round(n_inb_depr, digits = 4)
```

$$M_0 - M_F = 2d\bar{p}\bar{q}F = 2 * `r n_het_geno_val` * `r n_maf_locus_w` * (1 -  `r n_maf_locus_w`) * `r n_F_t_limit` =  `r n_inb_depr_rounded`$$

\solend

\clearpage
\pagebreak

\begin{enumerate}
\item[d)] Inbreeding has an influence on the genetic additive variance, as it is split into a between line and a within line component. Please, fill out the following table with the different genetic variance components for the locus $W$ from Problem 5c. We assume a value of  $`r n_F_t_limit`$ for the inbreeding coefficient $F$. 

\textit{Inzucht hat einen Einfluss auf die additive genetische Varianz, da diese Varianz durch die Inzucht in eine Komponente innerhalb Linie und eine Komponente zwischen Linien aufgeteilt wird. Bitte füllen Sie die folgende Tabelle mit den unterschiedlichen Varianzkomponenten am Genort $W$ aus Aufgabe 5c aus. Als Inzuchtkoeffizienten $F$ nehmen wir einen Wert von $`r n_F_t_limit`$ an.}
\points{`r lPointsQ5$TaskD`}
\end{enumerate}


\vspace{3ex}
__Solution__:

```{r prob1d-table, echo=FALSE}
tbl_gen_anova_task <- tibble::tibble(Source = c("Between lines", "Within lines","Total additive", "Dominance", "Total genetic"),
                                    Variance = c("", "", "", "", ""))

knitr::kable(tbl_gen_anova_task,
             booktabs = TRUE, 
             escape = FALSE,
             format = 'latex')  %>%
  kableExtra::kable_styling(position = 'center', latex_options = c("HOLD_position")) %>%
  kableExtra::column_spec(2, width = "8cm") %>%
  kableExtra::row_spec(1:nrow(tbl_gen_anova_task), font_size = 12)
```


\vspace{3ex}
\solstart

```{r prob1d-sol, echo=FALSE}
n_add_gen_var_base_pop <- 2 * n_maf_locus_w * (1-n_maf_locus_w) * n_homo_geno_val^2
n_bt_line <- 2*n_F_t_limit * n_add_gen_var_base_pop
n_win_line <- (1-n_F_t_limit) * n_add_gen_var_base_pop
n_add_gen_var <- (1+n_F_t_limit) * n_add_gen_var_base_pop
n_dom_gen_var <- (2 * n_maf_locus_w * (1-n_maf_locus_w) * n_het_geno_val)^2
n_total_var <- (1+n_F_t_limit) * n_add_gen_var_base_pop + n_dom_gen_var
tbl_gen_anova_sol <- tibble::tibble(Source = c("Between lines", "Within lines","Total additive", "Dominance", "Total genetic"),
                                    Variance = c("$2FV_U$", "$(1-F)V_U$", "$(1+F)V_U$", "$V_D$", "$V_G$"),
                                    Values   = round(c(n_bt_line,
                                                 n_win_line,
                                                 n_add_gen_var,
                                                 n_dom_gen_var,
                                                 n_total_var), digits = 2))

knitr::kable(tbl_gen_anova_sol,
             booktabs = TRUE, 
             escape = FALSE,
             format = 'latex')  %>%
  kableExtra::kable_styling(position = 'center', latex_options = c("HOLD_position"))
```

\solend
